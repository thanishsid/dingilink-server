// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: message.sql

package db

import (
	"context"

	"github.com/thanishsid/dingilink-server/internal/types"
)

const CheckMessagesHasNextPage = `-- name: CheckMessagesHasNextPage :one
SELECT EXISTS(
    SELECT 1 FROM messages m 
    WHERE
        CASE 
            WHEN $1::BIGINT IS NOT NULL THEN
                (m.sender_id = $2::BIGINT OR m.recipient_id = $2::BIGINT)
                AND
                (m.sender_id = $1::BIGINT OR m.recipient_id = $1::BIGINT)
            WHEN $3::BIGINT IS NOT NULL THEN
                m.group_id = $3::BIGINT
        END
        AND
        (m.id < $4::BIGINT)
)
`

type CheckMessagesHasNextPageParams struct {
	TargetUserID  *int64
	CurrentUserID int64
	TargetGroupID *int64
	CursorID      int64
}

func (q *Queries) CheckMessagesHasNextPage(ctx context.Context, arg CheckMessagesHasNextPageParams) (bool, error) {
	row := q.db.QueryRow(ctx, CheckMessagesHasNextPage,
		arg.TargetUserID,
		arg.CurrentUserID,
		arg.TargetGroupID,
		arg.CursorID,
	)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const CheckMessagesHasPreviousPage = `-- name: CheckMessagesHasPreviousPage :one
SELECT EXISTS(
    SELECT 1 FROM messages m 
    WHERE
        CASE 
            WHEN $1::BIGINT IS NOT NULL THEN
                (m.sender_id = $2::BIGINT OR m.recipient_id = $2::BIGINT)
                AND
                (m.sender_id = $1::BIGINT OR m.recipient_id = $1::BIGINT)
            WHEN $3::BIGINT IS NOT NULL THEN
                m.group_id = $3::BIGINT
        END
        AND
        (m.id > $4::BIGINT)
)
`

type CheckMessagesHasPreviousPageParams struct {
	TargetUserID  *int64
	CurrentUserID int64
	TargetGroupID *int64
	CursorID      int64
}

func (q *Queries) CheckMessagesHasPreviousPage(ctx context.Context, arg CheckMessagesHasPreviousPageParams) (bool, error) {
	row := q.db.QueryRow(ctx, CheckMessagesHasPreviousPage,
		arg.TargetUserID,
		arg.CurrentUserID,
		arg.TargetGroupID,
		arg.CursorID,
	)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const GetBatchedMessages = `-- name: GetBatchedMessages :many
SELECT id, sender_id, recipient_id, group_id, message_type, text_content, media, location, reply_for_message_id, sent_at, deleted_at, deleted_by FROM messages WHERE id = ANY($1::BIGINT[])
`

func (q *Queries) GetBatchedMessages(ctx context.Context, messageIds []int64) ([]Message, error) {
	rows, err := q.db.Query(ctx, GetBatchedMessages, messageIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Message
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.SenderID,
			&i.RecipientID,
			&i.GroupID,
			&i.MessageType,
			&i.TextContent,
			&i.Media,
			&i.Location,
			&i.ReplyForMessageID,
			&i.SentAt,
			&i.DeletedAt,
			&i.DeletedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetChats = `-- name: GetChats :many
WITH chat_messages AS (
    SELECT 
        COALESCE(m.group_id, CASE WHEN m.sender_id = $1 THEN m.recipient_id ELSE m.sender_id END) AS chat_id, 
        (m.group_id IS NOT NULL)::BOOLEAN AS is_group_chat, 
        MAX(m.sent_at) AS last_message_time
    FROM messages m
    WHERE (m.sender_id = $1 OR m.recipient_id = $1 OR m.group_id IN (
        SELECT gm.group_id FROM group_members gm WHERE gm.user_id = $1
    ))
    GROUP BY chat_id, is_group_chat
),
last_message AS (
    SELECT 
        COALESCE(m.group_id, CASE WHEN m.sender_id = $1 THEN m.recipient_id ELSE m.sender_id END) AS chat_id, 
        m.id AS message_id, 
        m.sender_id,
        m.recipient_id,
        m.group_id,
        m.text_content,
        m.media,
        m.sent_at
    FROM messages m
    WHERE (m.sender_id = $1 OR m.recipient_id = $1 OR m.group_id IN (
        SELECT gm.group_id FROM group_members gm WHERE gm.user_id = $1
    ))
),
unread_count AS (
    SELECT 
        COALESCE(m.group_id, CASE WHEN m.sender_id = $1 THEN m.recipient_id ELSE m.sender_id END) AS chat_id, 
        COUNT(m.id) AS unread_messages_count
    FROM messages m
    LEFT JOIN message_read_receipts mrr ON m.id = mrr.message_id AND mrr.user_id = $1
    WHERE m.sender_id <> $1 
      AND (m.recipient_id = $1 OR m.group_id IN (
        SELECT gm.group_id FROM group_members gm WHERE gm.user_id = $1
      )) 
      AND mrr.message_id IS NULL
    GROUP BY chat_id
)
SELECT 
    cm.chat_id,
    cm.is_group_chat,
    COALESCE(g.name, u.name) AS chat_name,
    lm.message_id AS last_message_id,
    COALESCE(uc.unread_messages_count, 0) AS unread_message_count
FROM chat_messages cm
JOIN last_message lm ON cm.chat_id = lm.chat_id AND cm.last_message_time = lm.sent_at
LEFT JOIN groups g ON cm.is_group_chat AND cm.chat_id = g.id
LEFT JOIN users u ON NOT cm.is_group_chat AND cm.chat_id = u.id
LEFT JOIN unread_count uc ON cm.chat_id = uc.chat_id
ORDER BY lm.sent_at DESC
`

type GetChatsRow struct {
	ChatID             *int64
	IsGroupChat        bool
	ChatName           string
	LastMessageID      int64
	UnreadMessageCount int64
}

func (q *Queries) GetChats(ctx context.Context, userID int64) ([]GetChatsRow, error) {
	rows, err := q.db.Query(ctx, GetChats, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChatsRow
	for rows.Next() {
		var i GetChatsRow
		if err := rows.Scan(
			&i.ChatID,
			&i.IsGroupChat,
			&i.ChatName,
			&i.LastMessageID,
			&i.UnreadMessageCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetMessages = `-- name: GetMessages :many
SELECT 
    m.id, m.sender_id, m.recipient_id, m.group_id, m.message_type, m.text_content, m.media, m.location, m.reply_for_message_id, m.sent_at, m.deleted_at, m.deleted_by 
FROM messages m 
WHERE
    CASE 
        WHEN $1::BIGINT IS NOT NULL THEN
            (m.sender_id = $2::BIGINT OR m.recipient_id = $2::BIGINT)
            AND
            (m.sender_id = $1::BIGINT OR m.recipient_id = $1::BIGINT)
        WHEN $3::BIGINT IS NOT NULL THEN
            m.group_id = $3::BIGINT
    END
    AND
    ($4::BIGINT IS NULL OR m.id < $4::BIGINT)
ORDER BY m.id DESC
LIMIT $5
`

type GetMessagesParams struct {
	TargetUserID  *int64
	CurrentUserID int64
	TargetGroupID *int64
	CursorID      *int64
	ResultLimit   int64
}

func (q *Queries) GetMessages(ctx context.Context, arg GetMessagesParams) ([]Message, error) {
	rows, err := q.db.Query(ctx, GetMessages,
		arg.TargetUserID,
		arg.CurrentUserID,
		arg.TargetGroupID,
		arg.CursorID,
		arg.ResultLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Message
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.SenderID,
			&i.RecipientID,
			&i.GroupID,
			&i.MessageType,
			&i.TextContent,
			&i.Media,
			&i.Location,
			&i.ReplyForMessageID,
			&i.SentAt,
			&i.DeletedAt,
			&i.DeletedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const InsertMessage = `-- name: InsertMessage :one
INSERT INTO messages (
    sender_id,
    recipient_id,
    group_id,
    message_type,
    text_content,
    media,
    location,
    reply_for_message_id
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8
) RETURNING id, sender_id, recipient_id, group_id, message_type, text_content, media, location, reply_for_message_id, sent_at, deleted_at, deleted_by
`

type InsertMessageParams struct {
	SenderID          int64
	RecipientID       *int64
	GroupID           *int64
	MessageType       string
	TextContent       *string
	Media             *string
	Location          types.Point
	ReplyForMessageID *int64
}

func (q *Queries) InsertMessage(ctx context.Context, arg InsertMessageParams) (Message, error) {
	row := q.db.QueryRow(ctx, InsertMessage,
		arg.SenderID,
		arg.RecipientID,
		arg.GroupID,
		arg.MessageType,
		arg.TextContent,
		arg.Media,
		arg.Location,
		arg.ReplyForMessageID,
	)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.SenderID,
		&i.RecipientID,
		&i.GroupID,
		&i.MessageType,
		&i.TextContent,
		&i.Media,
		&i.Location,
		&i.ReplyForMessageID,
		&i.SentAt,
		&i.DeletedAt,
		&i.DeletedBy,
	)
	return i, err
}
